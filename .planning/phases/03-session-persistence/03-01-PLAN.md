---
phase: 03-session-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bridge/session-manager.ts
  - src/claude/types.ts
  - src/bridge/router.ts
autonomous: true

must_haves:
  truths:
    - "SessionManager can create, destroy, and look up sessions by thread ID"
    - "Multiple concurrent ManagedSession instances can coexist independently"
    - "BridgeRouter delegates session creation and routing to SessionManager"
    - "Permission requests route to the correct session's thread in multi-session scenarios"
    - "Cost and token data accumulate per-session from ResultEvent"
  artifacts:
    - path: "src/bridge/session-manager.ts"
      provides: "Multi-session registry with lifecycle management"
      exports: ["SessionManager", "ManagedSession"]
    - path: "src/claude/types.ts"
      provides: "Extended types for session management"
      contains: "ManagedSession"
    - path: "src/bridge/router.ts"
      provides: "Refactored bridge router using SessionManager"
      contains: "SessionManager"
  key_links:
    - from: "src/bridge/session-manager.ts"
      to: "src/claude/session.ts"
      via: "ClaudeSession creation per ManagedSession"
      pattern: "new ClaudeSession"
    - from: "src/bridge/router.ts"
      to: "src/bridge/session-manager.ts"
      via: "SessionManager for multi-session delegation"
      pattern: "sessionManager"
    - from: "src/bridge/router.ts"
      to: "src/bridge/ipc-server.ts"
      via: "Session-aware permission routing using activeThread per session"
      pattern: "getSession.*threadId"
---

<objective>
Build the SessionManager class and refactor BridgeRouter for multi-session support.

Purpose: Transform the existing single-session architecture (BridgeRouter owns one ClaudeSession) into a multi-session system where a SessionManager registry maps Discord thread IDs to independent ManagedSession instances. This is the foundation that all Phase 3 commands and UX depend on.

Output: SessionManager class, ManagedSession interface, refactored BridgeRouter that delegates to SessionManager for session lifecycle and message routing.
</objective>

<execution_context>
@/Users/erictrang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/erictrang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-session-persistence/03-RESEARCH.md

@src/claude/session.ts
@src/claude/types.ts
@src/bridge/router.ts
@src/bridge/ipc-server.ts
@src/bridge/permission-handler.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ManagedSession interface and SessionManager class</name>
  <files>src/bridge/session-manager.ts, src/claude/types.ts</files>
  <action>
1. In `src/claude/types.ts`, add the `ManagedSession` interface after the existing `SessionOptions`:

```typescript
export interface ManagedSession {
  id: string;                    // Internal session ID (crypto.randomUUID())
  claudeSession: ClaudeSession;  // The Claude CLI process wrapper
  threadId: string;              // Discord thread ID
  threadUrl: string;             // Discord thread URL for display
  startedAt: Date;               // When session was created
  messageCount: number;          // Messages sent in this session
  lastActivityAt: Date;          // Last message timestamp
  totalCostUsd: number;          // Cumulative from ResultEvent.total_cost_usd (assign, not add)
  totalInputTokens: number;      // Accumulated from ResultEvent.usage.input_tokens (add per turn)
  totalOutputTokens: number;     // Accumulated from ResultEvent.usage.output_tokens (add per turn)
  isProcessing: boolean;         // Currently waiting for Claude response
}
```

Note: Import `ClaudeSession` type via `import type` to avoid circular dependency. The type is needed only for the interface shape.

2. Create `src/bridge/session-manager.ts` with the `SessionManager` class:

```typescript
import crypto from "node:crypto";
import { ClaudeSession } from "../claude/session.js";
import type { ManagedSession, SessionOptions } from "../claude/types.js";
import { logger } from "../logger.js";
```

Class structure:
- **Private field:** `sessions: Map<string, ManagedSession>` (key = Discord thread ID)
- **Private field:** `sessionOptions: SessionOptions` (cwd, ipcPort, dangerouslySkipPermissions -- used to spawn new ClaudeSession instances)

**Constructor:** Takes `SessionOptions` (same options passed to ClaudeSession).

**Lifecycle methods:**
- `createSession(threadId: string, threadUrl: string): ManagedSession` -- Creates a new ClaudeSession with `this.sessionOptions`, calls `.spawn()`, creates a ManagedSession object with fresh metadata, stores in map, returns it. Uses `crypto.randomUUID()` for the session id.
- `destroySession(threadId: string): ManagedSession | undefined` -- Calls `claudeSession.destroy()` on the session, removes from map, returns the destroyed session (or undefined if not found). Log the destruction.
- `destroyAllSessions(): number` -- Iterates all sessions, calls destroy on each, clears the map, returns count destroyed.

**Lookup methods:**
- `getSession(threadId: string): ManagedSession | undefined` -- Direct map lookup.
- `getAllSessions(): ManagedSession[]` -- Returns `Array.from(this.sessions.values())`.
- `getActiveSessionCount(): number` -- Returns `this.sessions.size`.
- `getMostRecentSession(): ManagedSession | undefined` -- Returns the session with the highest `lastActivityAt` timestamp (use `Array.from(this.sessions.values()).sort(...)` by `lastActivityAt` descending, return first).
- `hasAnySessions(): boolean` -- Returns `this.sessions.size > 0`.

**Cost tracking method:**
- `updateSessionCosts(threadId: string, result: ResultEvent): void` -- Given a ResultEvent, update the session's cost/token fields. `totalCostUsd = result.total_cost_usd` (assign, not add -- it's cumulative per CLI process). `totalInputTokens += result.usage.input_tokens`, `totalOutputTokens += result.usage.output_tokens` (per-turn, so accumulate). Import `ResultEvent` from types.

Export both `SessionManager` and re-export `ManagedSession` from this module.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile. The SessionManager should have no runtime dependencies on Discord -- it only depends on ClaudeSession and types.
  </verify>
  <done>
SessionManager class exists with create/destroy/lookup/cost methods. ManagedSession interface is defined in types.ts. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor BridgeRouter for multi-session delegation and session-aware permission routing</name>
  <files>src/bridge/router.ts</files>
  <action>
Refactor `BridgeRouter` to use `SessionManager` instead of owning a single `ClaudeSession`. The router becomes a thin orchestration layer that creates sessions via SessionManager and routes messages to the correct session.

**Constructor changes:**
- Remove `session: ClaudeSession` parameter.
- Add `sessionManager: SessionManager` parameter.
- Keep `ipcServer` and `permissionHandler` parameters.
- Remove `cwd` parameter (SessionManager owns the session creation config).
- Store `sessionManager` as a private readonly field.
- Keep the IPC `permission-request` event wiring (but update the handler -- see below).

**Remove these fields:**
- `private readonly session: ClaudeSession` (replaced by sessionManager)
- `private readonly cwd: string` (owned by SessionManager)
- `private activeThread: ThreadChannel | null` (each session tracks its own thread)

**Keep these fields:**
- `private isProcessing = false` -- BUT this is now per-session. Remove the global `isProcessing` field. Instead, use `ManagedSession.isProcessing`.
- `private messageQueue: QueuedMessage[]` -- Keep for now. Message queuing is still needed per-session. However, the simpler approach: remove the global queue. Each session's ClaudeSession already processes one message at a time (stream-json is sequential). The queuing at the router level was for the single-session case. With multi-session, each thread's messages go to its own session. Keep a lightweight check: if `session.isProcessing`, queue within that session context. For simplicity in this refactor, keep the queue but scope it to prevent the same session from double-processing.

**Refactored `handleMessage`:**
The method now takes `(message: Message, thread: ThreadChannel, session: ManagedSession)` instead of creating the thread itself. Thread creation moves to the `/new` command (Plan 02) or to a new method `handleNewMessage(message: Message)` that creates a thread and session, then delegates to `handleMessage`.

Provide two entry points:
1. `handleNewMessage(message: Message): Promise<void>` -- For messages in the main channel. Creates a thread (with first 95 chars of content as name, `ThreadAutoArchiveDuration.OneDay` per research recommendation to avoid archive issues), calls `sessionManager.createSession(thread.id, thread.url)`, then delegates to `handleSessionMessage(message, thread, session)`.
2. `handleSessionMessage(message: Message, thread: ThreadChannel, session: ManagedSession): Promise<void>` -- For messages in an existing session thread. This is the refactored version of the old `handleMessage`. Uses `session.claudeSession.sendMessage()` to send and stream events. Updates `session.isProcessing`, `session.messageCount++`, `session.lastActivityAt`.

In `handleSessionMessage`:
- If `session.isProcessing` is true, send a queued notice in the thread and return (or queue -- keep it simple, just reject with a message for now).
- Set `session.isProcessing = true` at start, `false` in finally block.
- `session.messageCount++` and `session.lastActivityAt = new Date()` at start.
- In the `result` event handler, call `sessionManager.updateSessionCosts(session.threadId, result)` to accumulate cost/token data.
- Remove the old `this.activeThread` references -- use the `thread` parameter directly.
- Remove the message queue processing (`processQueue`). With multi-session, each session handles one message at a time; the user can send messages to other sessions while one is processing.

**Refactored `handleStreamEvent`:**
No major changes needed. The method already receives context via the `ctx` parameter. Just ensure it uses the passed thread rather than `this.activeThread`.

In the `result` case, change `if (this.activeThread)` to use the thread from context. Add a `thread` field to the `ctx` parameter type and use it for posting error messages and cost info.

**Session-aware permission routing:**
The `handlePermissionEvent` method currently uses `this.activeThread` to route permission prompts. With multi-session, it needs to figure out which session the permission request belongs to.

Strategy: When a session starts processing (`handleSessionMessage`), store a reference to the current thread on the router as `private processingThreads: Map<string, ThreadChannel>`. The key is... actually, the simplest approach: since all sessions share a single IPC server and single MCP permission server process, permission requests arrive without a session identifier.

The solution: Track which sessions are currently processing. Since `session.isProcessing` is set to true during message handling, find the session that is processing. If exactly one session is processing, route to its thread. If multiple are processing (shouldn't happen with sequential processing per session, but could with concurrent sessions), use the most recently active one.

Implement: `private getPermissionThread(): ThreadChannel | null` -- iterates `sessionManager.getAllSessions()`, finds ones where `isProcessing === true`, returns the thread for the most recently active one. Cache the thread reference by storing `activeThreads: Map<string, ThreadChannel>` (threadId -> ThreadChannel). Set the entry when `handleSessionMessage` starts, delete it in the finally block.

Update `handlePermissionEvent` to use `getPermissionThread()` instead of `this.activeThread`.

**Refactored `abort` method:**
Change signature to `abort(threadId?: string): boolean`. If threadId provided, abort that specific session. If not, abort all processing sessions. Call `session.claudeSession.abortTurn()`.

**Refactored `getStatus` method:**
Remove this method -- `/status` will query SessionManager directly in Plan 02.

**Remove `resetSession` method:**
This was for `/new` to destroy and respawn. With SessionManager, `/new` creates a new session. `/stop` destroys a specific one. The router doesn't need a reset method.

**Remove `startTypingLoop` and `processQueue`:**
Move `startTypingLoop` to be a private utility within `handleSessionMessage` (keep it in the same file, just update references). Remove `processQueue` entirely.

Export `BridgeRouter` with the new interface.
  </action>
  <verify>
Run `npx tsc --noEmit`. Expect compilation errors in `src/index.ts` (wiring not yet updated -- that's Plan 02). The key check: `router.ts` and `session-manager.ts` compile cleanly against each other. Temporarily comment out the index.ts imports if needed to verify, or just check that the errors are ONLY in index.ts/commands (which Plan 02 will fix).
  </verify>
  <done>
BridgeRouter accepts SessionManager instead of a single ClaudeSession. `handleNewMessage` creates threads+sessions for main channel messages. `handleSessionMessage` routes messages to existing sessions. Permission routing uses `getPermissionThread()` to find the correct session's thread. No global `activeThread` or `isProcessing` state -- all per-session via ManagedSession.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- types compile (expect errors only in files not yet updated: index.ts, commands)
2. SessionManager can be instantiated with SessionOptions
3. BridgeRouter constructor takes SessionManager instead of ClaudeSession
4. No references to single `this.session` or `this.activeThread` remain in router.ts
5. Permission routing is session-aware (uses getPermissionThread or equivalent)
</verification>

<success_criteria>
- SessionManager class exists with full lifecycle API (create, destroy, lookup, cost tracking)
- ManagedSession interface captures all per-session metadata (thread, costs, tokens, timing)
- BridgeRouter delegates to SessionManager for all session operations
- Permission requests route to the correct session's thread
- TypeScript compiles (errors only in downstream consumers not yet updated)
</success_criteria>

<output>
After completion, create `.planning/phases/03-session-persistence/03-01-SUMMARY.md`
</output>
