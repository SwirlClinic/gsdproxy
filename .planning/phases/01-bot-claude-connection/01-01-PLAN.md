---
phase: 01-bot-claude-connection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .env.example
  - .gitignore
  - src/config.ts
  - src/index.ts
  - src/discord/client.ts
  - src/discord/commands/index.ts
  - src/discord/commands/status.ts
  - src/discord/commands/stop.ts
  - src/discord/commands/new.ts
  - src/discord/handlers/interaction.ts
  - src/discord/handlers/message.ts
autonomous: true
user_setup:
  - service: discord
    why: "Bot needs a Discord application and bot token to connect"
    env_vars:
      - name: DISCORD_TOKEN
        source: "Discord Developer Portal -> Applications -> Bot -> Token"
      - name: DISCORD_APP_ID
        source: "Discord Developer Portal -> Applications -> General Information -> Application ID"
      - name: DISCORD_GUILD_ID
        source: "Discord -> Server Settings -> Widget -> Server ID (or right-click server with Developer Mode)"
      - name: DISCORD_CHANNEL_ID
        source: "Right-click the dedicated channel with Developer Mode enabled -> Copy Channel ID"
      - name: DISCORD_OWNER_ID
        source: "Discord -> User Settings -> Advanced -> Developer Mode, then right-click your username -> Copy User ID"

must_haves:
  truths:
    - "Running `npm run dev` starts the bot and it appears online in Discord"
    - "Only the configured owner Discord user ID can trigger message handling or use slash commands"
    - "Slash commands /status, /stop, /new are registered and respond in the dedicated channel"
    - "Messages outside the dedicated channel are ignored"
    - "Bot messages and own messages are ignored (no self-reply loops)"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with bin entry for gsdproxy, dependencies, scripts"
      contains: "gsdproxy"
    - path: "src/config.ts"
      provides: "Validated environment configuration"
      exports: ["config"]
    - path: "src/discord/client.ts"
      provides: "Discord.js client setup with required intents"
      exports: ["client"]
    - path: "src/discord/commands/index.ts"
      provides: "Command registry and REST registration"
      exports: ["registerCommands", "commands"]
    - path: "src/discord/handlers/message.ts"
      provides: "messageCreate handler with owner guard and channel filter"
      exports: ["handleMessage"]
    - path: "src/discord/handlers/interaction.ts"
      provides: "interactionCreate handler routing to slash commands"
      exports: ["handleInteraction"]
    - path: "src/index.ts"
      provides: "Entry point that wires Discord client, registers commands, attaches handlers"
      min_lines: 20
  key_links:
    - from: "src/index.ts"
      to: "src/discord/client.ts"
      via: "imports client, calls client.login()"
      pattern: "client\\.login"
    - from: "src/discord/handlers/message.ts"
      to: "src/config.ts"
      via: "checks message.channel.id === config.channelId and message.author.id === config.ownerId"
      pattern: "config\\.(channelId|ownerId)"
    - from: "src/discord/handlers/interaction.ts"
      to: "src/discord/commands/"
      via: "routes interaction.commandName to command handlers"
      pattern: "commandName"
---

<objective>
Scaffold the gsdproxy project and build the Discord bot foundation -- client connection, slash command registration, owner-only access control, and message/interaction handler skeletons.

Purpose: Establish the project structure and a working Discord bot that comes online, accepts messages in a dedicated channel from the owner only, and responds to slash commands. This is the foundation that Plan 02 wires Claude into.

Output: A runnable Discord bot with /status, /stop, /new commands and a message handler that logs incoming messages (Claude integration added in Plan 02).
</objective>

<execution_context>
@/Users/erictrang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/erictrang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bot-claude-connection/01-CONTEXT.md
@.planning/phases/01-bot-claude-connection/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffold and configuration</name>
  <files>
    package.json
    tsconfig.json
    .env.example
    .gitignore
    src/config.ts
  </files>
  <action>
Initialize the Node.js project with the following exact setup:

**package.json:**
- name: "gsdproxy"
- version: "0.1.0"
- type: "module" (ESM)
- bin: { "gsdproxy": "./dist/index.js" }
- scripts: dev ("tsx watch src/index.ts"), build ("tsc"), start ("node dist/index.js")
- Dependencies: discord.js@^14.25.0, dotenv@^16.4.0, pino@^10.1.0
- DevDependencies: typescript@^5.9.0, tsx@^4.21.0, @types/node@^22.0.0, pino-pretty@^13.0.0

**tsconfig.json:**
- target: "ES2022", module: "Node16", moduleResolution: "Node16"
- outDir: "./dist", rootDir: "./src"
- strict: true, esModuleInterop: true, skipLibCheck: true
- Include: ["src/**/*"]

**.env.example:**
```
DISCORD_TOKEN=your-bot-token
DISCORD_APP_ID=your-app-id
DISCORD_GUILD_ID=your-guild-id
DISCORD_CHANNEL_ID=your-channel-id
DISCORD_OWNER_ID=your-discord-user-id
```

**.gitignore:**
node_modules/, dist/, .env (not .env.example)

**src/config.ts:**
- Load dotenv at import time
- Export a `config` object with: token, appId, guildId, channelId, ownerId (all from process.env)
- Validate all five are present at module load. If any missing, throw a clear error message naming the missing variable(s).
- Export `cwd` as `process.cwd()` (fixed at startup per user decision)

Run `npm install` after creating package.json.
  </action>
  <verify>
Run `npm run build` -- should compile without errors (once all source files exist). For now, verify `npm install` succeeds and `npx tsc --noEmit --pretty` reports no config errors.
  </verify>
  <done>
Project has package.json with correct bin/scripts/deps, tsconfig compiles ESM TypeScript, config.ts validates all required env vars at load time, npm install completed successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Discord client, slash commands, and handler wiring</name>
  <files>
    src/discord/client.ts
    src/discord/commands/index.ts
    src/discord/commands/status.ts
    src/discord/commands/stop.ts
    src/discord/commands/new.ts
    src/discord/handlers/message.ts
    src/discord/handlers/interaction.ts
    src/index.ts
  </files>
  <action>
**src/discord/client.ts:**
- Create and export a Discord.js Client with intents: Guilds, GuildMessages, MessageContent
- Do NOT call login here -- that happens in index.ts

**src/discord/commands/status.ts:**
- Export a SlashCommandBuilder for /status ("Show current Claude session status")
- Export an execute function that takes a ChatInputCommandInteraction
- For now, reply with session status placeholder: "No active session. Working directory: {cwd}" or "Session active: {sessionId}" -- the bridge will populate this in Plan 02. Use a simple exported getter pattern (e.g., `let getSessionStatus: () => string` that defaults to "No active session") that Plan 02 can override.

**src/discord/commands/stop.ts:**
- Export a SlashCommandBuilder for /stop ("Stop the active Claude session immediately")
- Export an execute function. For now, reply "No active session to stop." Plan 02 will wire in the actual kill logic via a callback pattern (e.g., `let onStop: () => boolean` that Plan 02 sets).

**src/discord/commands/new.ts:**
- Export a SlashCommandBuilder for /new ("Start a fresh Claude session")
- Export an execute function. Reply "Session reset. Next message starts a new conversation." Plan 02 will wire the actual session reset.

**src/discord/commands/index.ts:**
- Import all command modules
- Export `commands` array of { data: SlashCommandBuilder, execute: Function }
- Export async `registerCommands(token, appId, guildId)` that uses REST to PUT guild commands
- Use Routes.applicationGuildCommands for guild-scoped registration (instant, no 1-hour cache)

**src/discord/handlers/message.ts:**
- Export `handleMessage(message: Message)` function
- Guard: return early if message.author.bot (prevent self-reply loops)
- Guard: return early if message.channel.id !== config.channelId (dedicated channel only)
- Guard: return early if message.author.id !== config.ownerId (owner only -- per BOTF-04). Send an ephemeral-style reply: "You are not authorized to use this bot." (Note: regular messages can't be ephemeral, so just reply and delete after 5 seconds, or simply ignore silently. Claude's discretion: ignore silently for non-owners to avoid noise, but log the attempt via pino.)
- If all guards pass: log the message content. The actual Claude forwarding will be wired in Plan 02. For now, reply with a placeholder: "Received: {truncated message}. Claude integration coming in next plan." This placeholder confirms the handler chain works end-to-end.

**src/discord/handlers/interaction.ts:**
- Export `handleInteraction(interaction: Interaction)` function
- Return early if not isChatInputCommand()
- Guard: return early if interaction.channelId !== config.channelId (dedicated channel only)
- Guard: return early if interaction.user.id !== config.ownerId (owner only). Reply ephemeral: "You are not authorized."
- Call `interaction.deferReply()` immediately (3-second timeout compliance per BOTF-06)
- Look up command by interaction.commandName from commands array
- Call command.execute(interaction)
- Wrap in try/catch: on error, editReply with error message (per BOTF-05: report errors in-channel)

**src/index.ts:**
- Import config, client, registerCommands, handleMessage, handleInteraction
- Wire client.once(Events.ClientReady) to log "Logged in as {tag}, channel: {channelId}, cwd: {cwd}" via pino
- Wire client.on(Events.MessageCreate) to handleMessage
- Wire client.on(Events.InteractionCreate) to handleInteraction
- Call registerCommands on startup (before or after login, either works)
- Call client.login(config.token)
- Add #!/usr/bin/env node shebang at top of index.ts for the bin entry

**Logging:** Use pino throughout. Create a logger instance in a shared location (can be in config.ts or a separate logger.ts). Use pino-pretty transport in development (detect via NODE_ENV or absence of NODE_ENV=production).

**Important:** All slash command execute functions should use `interaction.editReply()` (not `interaction.reply()`) since we deferReply() first. This is critical for the 3-second timeout compliance.
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- zero type errors
2. Create a temporary .env with valid Discord credentials and run `npm run dev`
3. Bot should appear online in Discord
4. Type a message in the dedicated channel as the owner -- should get placeholder response
5. Type /status -- should get deferred reply with session info
6. Type /stop -- should get "No active session" reply
  </verify>
  <done>
Discord bot starts, appears online, registers /status /stop /new commands. Messages in the dedicated channel from the owner get a placeholder response. Messages from non-owners or outside the channel are ignored. Slash commands defer immediately and respond. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run dev` starts the bot and it appears online in Discord
3. Owner sends a message in the dedicated channel -> gets placeholder response
4. Non-owner sends a message in the dedicated channel -> ignored (logged)
5. Message in a different channel -> ignored
6. /status in dedicated channel -> deferred reply with placeholder status
7. /stop in dedicated channel -> "No active session"
8. /new in dedicated channel -> "Session reset" confirmation
</verification>

<success_criteria>
- Project scaffolded with all dependencies installed and TypeScript compiling
- Discord bot connects and appears online
- Owner-only access control works for both messages and slash commands
- All three slash commands registered and responding
- Message handler correctly filters by channel and owner
- Entry point wires everything together and bot is runnable via `npm run dev`
</success_criteria>

<output>
After completion, create `.planning/phases/01-bot-claude-connection/01-01-SUMMARY.md`
</output>
