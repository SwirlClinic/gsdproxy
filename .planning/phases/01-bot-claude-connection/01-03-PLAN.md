---
phase: 01-bot-claude-connection
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/claude/types.ts
  - src/claude/process.ts
  - src/claude/parser.ts
  - src/bridge/router.ts
  - src/discord/handlers/message.ts
  - src/discord/commands/status.ts
  - src/discord/commands/stop.ts
  - src/discord/commands/new.ts
  - src/index.ts
autonomous: false

must_haves:
  truths:
    - "User types a message in Discord and receives Claude's formatted response"
    - "Follow-up messages continue the same Claude session (--continue flag used)"
    - "/stop kills the active Claude process and posts confirmation"
    - "/new resets the session so the next message starts fresh"
    - "/status shows whether Claude is processing and the current session ID"
    - "Tool activity is shown in Discord as italic status messages while Claude works"
    - "Typing indicator stays active while Claude is processing"
    - "Bot stops gracefully on SIGINT/SIGTERM without orphaned claude processes"
    - "Concurrent messages are queued with a notification"
    - "Long responses are split using the formatter at natural boundaries"
  artifacts:
    - path: "src/claude/types.ts"
      provides: "TypeScript types for stream-json message events"
      exports: ["ClaudeStreamEvent", "SystemInitEvent", "StreamEvent", "AssistantEvent", "ResultEvent"]
    - path: "src/claude/process.ts"
      provides: "Spawn claude CLI subprocess with correct flags"
      exports: ["spawnClaude"]
    - path: "src/claude/parser.ts"
      provides: "NDJSON stream parser as async generator"
      exports: ["parseStream"]
    - path: "src/bridge/router.ts"
      provides: "Routes Discord messages to Claude, manages session state, handles responses"
      exports: ["BridgeRouter"]
  key_links:
    - from: "src/bridge/router.ts"
      to: "src/claude/process.ts"
      via: "calls spawnClaude() with prompt and session options"
      pattern: "spawnClaude"
    - from: "src/bridge/router.ts"
      to: "src/claude/parser.ts"
      via: "iterates parseStream() async generator to consume events"
      pattern: "parseStream"
    - from: "src/bridge/router.ts"
      to: "src/discord/formatter.ts"
      via: "calls splitMessage() on accumulated text before sending to Discord"
      pattern: "splitMessage"
    - from: "src/discord/handlers/message.ts"
      to: "src/bridge/router.ts"
      via: "calls router.handleMessage() to forward Discord message to Claude"
      pattern: "router\\.handleMessage"
    - from: "src/index.ts"
      to: "src/bridge/router.ts"
      via: "creates BridgeRouter instance and passes to handlers"
      pattern: "new BridgeRouter|BridgeRouter"
    - from: "src/bridge/router.ts"
      to: "channel.sendTyping"
      via: "typing indicator loop while Claude processes"
      pattern: "sendTyping"
---

<objective>
Wire the Claude CLI integration into the Discord bot -- spawn claude as a subprocess, parse its NDJSON stream output, route messages bidirectionally between Discord and Claude, and handle session continuity, tool activity display, graceful shutdown, and message queuing.

Purpose: This is the core value delivery -- making the Discord channel a working proxy to Claude Code. After this plan, the user can have a full conversation with Claude from Discord.

Output: A fully functional Discord-to-Claude bridge that processes messages, shows tool activity, splits long responses, and handles /stop, /new, /status correctly.
</objective>

<execution_context>
@/Users/erictrang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/erictrang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bot-claude-connection/01-CONTEXT.md
@.planning/phases/01-bot-claude-connection/01-RESEARCH.md
@.planning/phases/01-bot-claude-connection/01-01-SUMMARY.md
@.planning/phases/01-bot-claude-connection/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Claude CLI types, process spawner, and NDJSON parser</name>
  <files>
    src/claude/types.ts
    src/claude/process.ts
    src/claude/parser.ts
  </files>
  <action>
**src/claude/types.ts:**
Define TypeScript types for the stream-json output format (per research docs):

```typescript
// Top-level event discriminated union
type ClaudeStreamEvent = SystemInitEvent | AssistantEvent | ResultEvent | StreamEvent;

interface SystemInitEvent {
  type: "system";
  subtype: "init";
  session_id: string;
  cwd: string;
  tools: string[];
  model: string;
}

interface StreamEvent {
  type: "stream_event";
  session_id: string;
  event: ContentBlockStart | ContentBlockDelta | ContentBlockStop | MessageStart | MessageDelta | MessageStop;
}

// Content block types for stream events
interface ContentBlockStart {
  type: "content_block_start";
  index: number;
  content_block: TextBlock | ToolUseBlock;
}

interface ContentBlockDelta {
  type: "content_block_delta";
  index: number;
  delta: TextDelta | InputJsonDelta;
}

interface ContentBlockStop {
  type: "content_block_stop";
  index: number;
}

// Delta types
interface TextDelta { type: "text_delta"; text: string; }
interface InputJsonDelta { type: "input_json_delta"; partial_json: string; }

// Block types
interface TextBlock { type: "text"; text: string; }
interface ToolUseBlock { type: "tool_use"; id: string; name: string; input: Record<string, unknown>; }

interface AssistantEvent {
  type: "assistant";
  session_id: string;
  message: { role: "assistant"; content: Array<TextBlock | ToolUseBlock>; };
}

interface ResultEvent {
  type: "result";
  subtype: "success" | "error_max_turns" | string;
  session_id: string;
  is_error: boolean;
  duration_ms?: number;
  num_turns?: number;
  result?: string;
  total_cost_usd?: number;
  usage?: { input_tokens: number; output_tokens: number; };
}
```

Also add MessageStart, MessageDelta, MessageStop types for completeness. Export all types.

**src/claude/process.ts:**
Export `spawnClaude(prompt: string, options: SpawnOptions): ChildProcess`

SpawnOptions: `{ cwd: string; continueSession?: boolean; sessionId?: string; }`

Implementation:
- Build args array: `["-p", prompt, "--output-format", "stream-json", "--verbose", "--include-partial-messages", "--allowedTools", "Read", "Glob", "Grep"]`
- Per user decision: CLI spawning with `--allowedTools` for read-only auto-approval (CLDI-03)
- If continueSession is true, prepend `--continue` to args
- If sessionId is provided (for future --resume), prepend `--resume`, sessionId
- Use `child_process.spawn("claude", args, { cwd: options.cwd, stdio: ["pipe", "pipe", "pipe"], env: process.env })`
- Return the ChildProcess

Do NOT use exec (buffers everything). Do NOT use node-pty (unnecessary for -p mode).

**src/claude/parser.ts:**
Export `parseStream(proc: ChildProcess): AsyncGenerator<ClaudeStreamEvent>`

Implementation:
- Use `readline.createInterface({ input: proc.stdout!, crlfDelay: Infinity })` (per research: handles partial lines correctly)
- For each line: trim, skip empty, JSON.parse, yield as ClaudeStreamEvent
- On parse error: log warning via pino but do NOT crash. Skip the malformed line.
- The async generator naturally completes when the readline interface closes (process exits)

Also export a helper to capture stderr: `captureStderr(proc: ChildProcess): Promise<string>` that accumulates proc.stderr into a string (useful for error reporting if claude process fails).
  </action>
  <verify>
1. `npx tsc --noEmit` -- zero type errors across all files
2. Types correctly narrow via discriminated unions (type field)
3. spawnClaude returns a ChildProcess with accessible stdout/stderr
4. parseStream yields typed events from a mock readline-compatible stream
  </verify>
  <done>
Claude CLI types fully defined with discriminated unions. spawnClaude spawns with correct flags including --verbose, --include-partial-messages, --allowedTools for read-only tools, and --continue for follow-ups. parseStream yields typed ClaudeStreamEvent objects from NDJSON stdout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bridge router, handler wiring, and graceful shutdown</name>
  <files>
    src/bridge/router.ts
    src/discord/handlers/message.ts
    src/discord/commands/status.ts
    src/discord/commands/stop.ts
    src/discord/commands/new.ts
    src/index.ts
  </files>
  <action>
**src/bridge/router.ts -- BridgeRouter class:**

This is the central orchestration class. It manages the Claude session and bridges Discord to Claude.

Constructor: `new BridgeRouter(cwd: string)`

State:
- `activeProcess: ChildProcess | null`
- `sessionId: string | null`
- `isProcessing: boolean`
- `messageQueue: Array<{ message: Message; resolve: () => void }>` (for concurrent message queuing)
- `hasSession: boolean` (true after first successful message, controls --continue flag)

**handleMessage(message: Message):**
1. If isProcessing: queue the message. Send a notification to the channel: "*Still working on your previous request. Your message has been queued.*" Return.
2. Set isProcessing = true
3. Start typing indicator loop: call `message.channel.sendTyping()` immediately, then setInterval at 9000ms. Store cleanup function.
4. Send status message: await `message.channel.send("*Working on it...*")` -- store reference to edit/delete later.
5. Spawn Claude: call `spawnClaude(message.content, { cwd: this.cwd, continueSession: this.hasSession })`
6. Store as activeProcess
7. Iterate parseStream(proc):
   - On `system` init: capture sessionId, set hasSession = true
   - On `stream_event` with content_block_start where content_block.type === "tool_use": extract tool name and input. Call `formatToolActivity(name, input)` from formatter.ts. Edit the status message to show the tool activity (e.g., "*Reading /src/auth.ts...*"). This fulfills the user decision to "show basic tool activity in Phase 1."
   - On `stream_event` with content_block_delta where delta.type === "text_delta": accumulate text into a buffer.
   - On `result`: stop typing indicator. Delete the status message. Split accumulated text via `splitMessage()`. Send each chunk as a separate Discord message. If result has cost/usage info, append a final italic message: "*Completed in {num_turns} turn(s) ($X.XXXX)*"
   - On `result` with is_error true: send error message to channel with the error details.
8. On process exit/error: clean up (isProcessing = false, activeProcess = null, stop typing). Process any queued messages.
9. On stderr output: log via pino. If the process exits with non-zero and stderr is non-empty, send error to channel.

**Error handling:**
- Wrap the entire handleMessage in try/catch. On any error, stop typing, send error to channel (BOTF-05), set isProcessing = false.
- If spawn fails (e.g., `claude` not found in PATH), send clear error: "Failed to start Claude. Is the `claude` CLI installed and in your PATH?"

**Queue processing:**
After a message completes, check if messageQueue has items. If so, shift the first one and call handleMessage recursively.

**abort():**
- If activeProcess: kill with SIGTERM. Set activeProcess = null, isProcessing = false.
- Clear message queue.
- Return true if a process was killed, false otherwise.

**getStatus():**
- Return object with: isProcessing, sessionId, cwd, queueLength

**resetSession():**
- Set hasSession = false, sessionId = null
- If isProcessing, abort first
- Next message will start a fresh session (no --continue)

**Update src/discord/handlers/message.ts:**
- Remove the placeholder response from Plan 01
- Import BridgeRouter
- Accept router as parameter or import from a shared module
- On valid message (passed all guards): call `router.handleMessage(message)`

**Update src/discord/commands/status.ts:**
- Accept a getStatus callback (set during wiring)
- Show: processing state, session ID (or "none"), working directory, queue length

**Update src/discord/commands/stop.ts:**
- Accept an abort callback (set during wiring)
- Call abort(). If returned true: editReply "Session stopped." If false: editReply "No active session to stop."

**Update src/discord/commands/new.ts:**
- Accept a resetSession callback (set during wiring)
- Call resetSession(). editReply "Session reset. Next message starts a new conversation."

**Update src/index.ts:**
- Create BridgeRouter instance with config.cwd
- Pass router to message handler (via closure, module-level variable, or dependency injection -- Claude's discretion on pattern)
- Wire command callbacks: status -> router.getStatus(), stop -> router.abort(), new -> router.resetSession()
- Add graceful shutdown: register `process.on("SIGINT")` and `process.on("SIGTERM")` handlers that:
  1. Call router.abort() to kill any active Claude process
  2. Call client.destroy() to disconnect from Discord
  3. Log "Shutting down gracefully"
  4. Call process.exit(0)
- Also register `process.on("exit")` as a safety net to kill any remaining child process

**Important implementation notes:**
- Per user decision: CLI spawning, NOT Agent SDK. Use child_process.spawn.
- Per user decision: typing indicator + status message showing tool activity.
- Per user decision: continuous conversation via --continue for follow-ups.
- Per user decision: /stop kills immediately (SIGTERM the child process).
- Per research: use readline for NDJSON parsing (not manual buffer splitting).
- Per research: cap at 10 split messages with truncation.
- Per research: queue concurrent messages with notification.
  </action>
  <verify>
1. `npx tsc --noEmit` -- zero type errors
2. `npm run dev` -- bot starts, appears online
3. Send a message in Discord -> Claude spawns, processes, responds with formatted output
4. Send a follow-up message -> uses --continue, Claude has conversation context
5. /status -> shows session info
6. /stop during processing -> kills Claude process, posts confirmation
7. /new -> resets session, next message starts fresh
8. Send two messages rapidly -> second gets "queued" notification, processes after first completes
9. Ctrl+C the bot -> no orphaned `claude` processes (verify with `ps aux | grep claude`)
10. Tool activity visible in Discord while Claude works (italic status messages)
  </verify>
  <done>
Full Discord-to-Claude bridge working. Messages forwarded to Claude CLI, responses formatted and split correctly, tool activity shown, typing indicator active during processing, /stop kills process, /new resets session, /status shows state, concurrent messages queued, graceful shutdown kills child processes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end verification</name>
  <files>none</files>
  <action>
Human verification of the complete Discord-to-Claude Code bridge. All automation is complete in Tasks 1-2. This checkpoint verifies the full end-to-end flow works correctly from the user's perspective.

What was built: Complete Discord-to-Claude Code bridge. The bot connects to Discord, accepts messages in a dedicated channel from the owner only, forwards them to the `claude` CLI via subprocess spawning with stream-json output, parses the NDJSON stream in real-time, shows tool activity, and sends formatted responses back to Discord. Supports continuous conversation (--continue), /stop to abort, /new to reset, /status to check state. Long messages split at natural boundaries. Graceful shutdown with no orphaned processes.
  </action>
  <verify>
1. Start the bot: `npm run dev` from the project directory
2. Verify bot appears online in Discord

**Basic message flow:**
3. In the dedicated channel, type: "What files are in this directory?"
4. Verify: typing indicator appears, status message shows tool activity, then Claude's response appears with proper formatting
5. Type a follow-up: "Tell me more about the first file"
6. Verify: Claude remembers context from the previous message (continuous conversation)

**Response formatting:**
7. Ask Claude something that produces code: "Show me a hello world in Python"
8. Verify: code block is properly formatted with syntax highlighting markers

**Slash commands:**
9. Run /status -- verify it shows session info (session ID, working directory)
10. Run /stop -- verify it reports session stopped (or no active session if idle)
11. Run /new then send a message -- verify Claude does NOT have context from previous messages

**Access control:**
12. Have another Discord user (or alt account) try to send a message in the channel -- verify it is ignored
13. Have another user try /status -- verify they get "not authorized"

**Graceful shutdown:**
14. While Claude is processing a message, press Ctrl+C in the terminal
15. Run `ps aux | grep claude` -- verify no orphaned processes
16. Verify bot goes offline in Discord

**Edge cases:**
17. Send two messages rapidly -- verify the second gets a "queued" notification and processes after the first
  </verify>
  <done>
All Phase 1 success criteria confirmed: bot starts and comes online, messages forwarded to Claude and responses formatted correctly, non-owner rejected, long responses split at boundaries, graceful shutdown with no orphaned processes. User types "approved" to confirm.
  </done>
</task>

</tasks>

<verification>
Phase 1 success criteria from ROADMAP.md:
1. User can start the bot from the command line and see it come online in Discord
2. User can type a message in Discord and receive Claude's response with proper markdown and code block formatting
3. A non-owner Discord user who tries to interact with the bot gets rejected
4. Long responses are split at natural boundaries (paragraph, code block) without breaking formatting
5. Bot stops gracefully when terminated, without orphaned processes

Requirements covered:
- BOTF-01: Start bot on-demand (npm run dev / gsdproxy command)
- BOTF-02: Stop bot gracefully (SIGINT/SIGTERM handlers + router.abort())
- BOTF-03: Connect to Discord and register slash commands on startup
- BOTF-04: Owner-only access (Discord user ID check in handlers)
- BOTF-05: Report errors in-channel (try/catch in handlers, error messages to channel)
- BOTF-06: Defer slash command interactions immediately (deferReply() before any async work)
- CLDI-01: Forward Discord messages to Claude Code CLI (spawn claude -p)
- CLDI-02: Display Claude's response with proper formatting (splitMessage + markdown)
- CLDI-03: Use --allowedTools for read-only auto-approval (Read, Glob, Grep)
- OUTD-01: Split long responses at natural boundaries (splitMessage with code fence awareness)
</verification>

<success_criteria>
- User runs `npm run dev`, bot appears online in Discord
- User sends a message, Claude processes it, formatted response appears in channel
- Follow-up messages maintain conversation context
- /status, /stop, /new all work correctly
- Non-owner messages are ignored
- Long responses split at paragraph/code block boundaries
- Tool activity visible as italic status messages
- Graceful shutdown with no orphaned processes
- Concurrent messages queued with notification
</success_criteria>

<output>
After completion, create `.planning/phases/01-bot-claude-connection/01-03-SUMMARY.md`
</output>
