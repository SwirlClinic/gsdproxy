---
phase: 01-bot-claude-connection
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/discord/formatter.ts
  - src/discord/formatter.test.ts
autonomous: true

must_haves:
  truths:
    - "Long responses are split at paragraph boundaries without breaking code blocks"
    - "Messages never exceed Discord's 2000-character limit"
    - "Code fences are never split mid-block"
    - "Empty input returns empty array, short input returns single-element array"
  artifacts:
    - path: "src/discord/formatter.ts"
      provides: "splitMessage function and formatToolActivity helper"
      exports: ["splitMessage", "formatToolActivity"]
    - path: "src/discord/formatter.test.ts"
      provides: "Test suite covering boundary splitting, code block preservation, edge cases"
      min_lines: 50
  key_links:
    - from: "src/discord/formatter.test.ts"
      to: "src/discord/formatter.ts"
      via: "imports splitMessage, formatToolActivity"
      pattern: "import.*splitMessage.*formatter"
---

<objective>
Build and test the Discord message formatter using TDD -- the splitMessage function that breaks long Claude responses at natural boundaries (paragraph, line, space) without splitting code blocks, and a formatToolActivity helper for tool status messages.

Purpose: Message splitting is pure logic with defined I/O, making it an ideal TDD candidate. Getting this right prevents broken code blocks and garbled output in Discord. This has no dependencies on the Discord client or Claude integration, so it runs in Wave 1 parallel with Plan 01.

Output: Fully tested formatter module ready to be imported by the bridge router in Plan 03.
</objective>

<execution_context>
@/Users/erictrang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/erictrang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-bot-claude-connection/01-CONTEXT.md
@.planning/phases/01-bot-claude-connection/01-RESEARCH.md
</context>

<feature>
  <name>Discord Message Formatter</name>
  <files>src/discord/formatter.ts, src/discord/formatter.test.ts</files>
  <behavior>
splitMessage(content: string, maxLength?: number): string[]
- Default maxLength: 1900 (buffer below Discord's 2000 limit for safety)
- Empty string -> []
- String shorter than maxLength -> [content]
- Long string -> split at double-newline (paragraph) boundaries first
- If no paragraph break within range, split at single newline
- If no newline, split at last space
- Last resort: hard split at maxLength
- CRITICAL: Never split inside a code fence (```...```). If a code block would be split, close it at the split point and re-open it in the next chunk.
- Each chunk must be a valid standalone Discord message (no orphaned code fences)
- Cap at 10 chunks maximum. If more would be needed, truncate the last chunk with "... (output truncated, {N} chars remaining)"

Test cases:
- "" -> []
- "short message" -> ["short message"]
- "para1\n\npara2" where total < max -> ["para1\n\npara2"]
- "para1\n\npara2" where para1 < max but total > max -> ["para1", "para2"]
- "line1\nline2\nline3..." where no paragraph breaks but line breaks exist -> splits at \n
- "word1 word2 word3..." where no line breaks -> splits at space
- "aaaaaa..." with no breaks -> hard splits at maxLength
- "text\n```js\nconst x = 1;\n```\nmore text" -> code block stays intact in one chunk
- "text\n```js\n{very long code}\n```" where code block exceeds maxLength -> closes ``` at split, reopens ```js in next chunk
- 11+ chunks scenario -> 10th chunk gets truncation notice

formatToolActivity(toolName: string, input?: Record<string, unknown>): string
- "Read" with { file_path: "/src/auth.ts" } -> "*Reading /src/auth.ts...*"
- "Glob" with { pattern: "**/*.ts" } -> "*Searching for **/*.ts...*"
- "Grep" with { pattern: "TODO" } -> "*Searching for TODO...*"
- "Bash" with { command: "npm test" } -> "*Running npm test...*"
- "Write" with { file_path: "/src/new.ts" } -> "*Writing /src/new.ts...*"
- "Edit" with { file_path: "/src/fix.ts" } -> "*Editing /src/fix.ts...*"
- Unknown tool "CustomTool" -> "*Using CustomTool...*"
  </behavior>
  <implementation>
RED phase: Create formatter.test.ts with all test cases above. Import from formatter.ts (which doesn't exist yet). Run vitest -- all tests fail.

GREEN phase: Implement splitMessage in formatter.ts:
1. Handle empty/short cases
2. While remaining > maxLength:
   a. Check if current position is inside a code fence (track open/close state)
   b. If inside a code fence that would be split: find the end of the code fence. If it fits, include it. If not, close the fence at a safe point, mark the language tag, and re-open in next chunk.
   c. Otherwise: try lastIndexOf("\n\n", maxLength), then lastIndexOf("\n", maxLength), then lastIndexOf(" ", maxLength), then hard split
   d. Don't split below 50% of maxLength (avoid tiny chunks)
3. Apply 10-chunk cap with truncation message

Implement formatToolActivity: simple switch/map on tool name to produce italic status string.

REFACTOR phase: Clean up any duplication in the split logic.

NOTE: vitest is already in devDependencies from Plan 01. If Plan 01 hasn't run yet (parallel wave), create a minimal package.json with just vitest to run tests, and Plan 01 will overwrite with the full one. Or better: add a "test": "vitest run" script and ensure vitest config works with the project's ESM setup. Add a vitest.config.ts if needed (vitest supports ESM + TypeScript natively).
  </implementation>
</feature>

<verification>
1. `npx vitest run src/discord/formatter.test.ts` -- all tests pass
2. No test uses hardcoded magic numbers (maxLength is parameterized)
3. Code fence test cases specifically verify no orphaned ``` in any chunk
4. Edge case: content that is exactly maxLength -> returns as single chunk (no split)
</verification>

<success_criteria>
- All test cases pass
- splitMessage never produces a chunk > maxLength
- splitMessage never produces orphaned code fences
- formatToolActivity returns correct italic status for all known tools
- Tests run in < 2 seconds
</success_criteria>

<output>
After completion, create `.planning/phases/01-bot-claude-connection/01-02-SUMMARY.md`
</output>
