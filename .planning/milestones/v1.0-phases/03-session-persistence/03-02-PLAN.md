---
phase: 03-session-persistence
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/discord/components/status-embed.ts
  - src/discord/components/session-picker.ts
  - src/discord/commands/new.ts
  - src/discord/commands/stop.ts
  - src/discord/commands/status.ts
  - src/discord/commands/continue.ts
  - src/discord/commands/help.ts
  - src/discord/commands/index.ts
  - src/discord/handlers/message.ts
  - src/index.ts
autonomous: false

must_haves:
  truths:
    - "User can run /new to create a fresh session with an auto-created thread"
    - "User sees a warning with confirm/cancel buttons when running /new with active sessions"
    - "User can run /stop and pick which session to stop from a select menu"
    - "User can run /stop with a single active session and it stops immediately"
    - "User can run /continue to resume the most recent session and gets a status embed in the thread"
    - "User can run /continue and gets notified if the session died, with option to start fresh or abort"
    - "User can run /status and see a rich embed with session info, token counts, and costs"
    - "Bot presence reflects session state: green=ready, yellow=sessions active, red=working"
    - "Messages in session threads route to the correct session"
    - "Messages in the main channel create a new session (backward compatible)"
  artifacts:
    - path: "src/discord/components/status-embed.ts"
      provides: "Rich embed builder for /status display"
      exports: ["createStatusEmbed"]
    - path: "src/discord/components/session-picker.ts"
      provides: "Select menu for choosing which session to stop"
      exports: ["createSessionPicker"]
    - path: "src/discord/commands/continue.ts"
      provides: "/continue command handler"
      exports: ["data", "execute"]
    - path: "src/discord/commands/new.ts"
      provides: "Refactored /new with active session warning"
      exports: ["data", "execute"]
    - path: "src/discord/commands/stop.ts"
      provides: "Refactored /stop with session picker"
      exports: ["data", "execute"]
    - path: "src/discord/commands/status.ts"
      provides: "Refactored /status with rich embed"
      exports: ["data", "execute"]
    - path: "src/index.ts"
      provides: "Wiring: SessionManager, refactored router, bot presence"
      contains: "SessionManager"
  key_links:
    - from: "src/discord/commands/new.ts"
      to: "src/bridge/session-manager.ts"
      via: "SessionManager.createSession for new sessions"
      pattern: "createSession"
    - from: "src/discord/commands/stop.ts"
      to: "src/bridge/session-manager.ts"
      via: "SessionManager.destroySession for stopping sessions"
      pattern: "destroySession"
    - from: "src/discord/commands/continue.ts"
      to: "src/bridge/session-manager.ts"
      via: "SessionManager.getMostRecentSession for resume"
      pattern: "getMostRecentSession"
    - from: "src/discord/commands/status.ts"
      to: "src/discord/components/status-embed.ts"
      via: "createStatusEmbed for rich display"
      pattern: "createStatusEmbed"
    - from: "src/index.ts"
      to: "src/bridge/session-manager.ts"
      via: "SessionManager creation and wiring"
      pattern: "new SessionManager"
    - from: "src/discord/handlers/message.ts"
      to: "src/bridge/router.ts"
      via: "Thread-based routing to handleNewMessage or handleSessionMessage"
      pattern: "handleNewMessage|handleSessionMessage"
---

<objective>
Implement all session lifecycle commands (/new, /stop, /continue, /status), Discord components, message routing, bot presence, and wire everything together.

Purpose: Deliver the user-facing session management experience. Users can create, stop, resume, and inspect sessions. The bot's presence indicator reflects session state. Messages route correctly to session threads. This completes Phase 3.

Output: Working multi-session system with all 4 session commands, rich status display, session picker, bot presence, and backward-compatible message routing.
</objective>

<execution_context>
@/Users/erictrang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/erictrang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-session-persistence/03-RESEARCH.md
@.planning/phases/03-session-persistence/03-01-SUMMARY.md

@src/bridge/session-manager.ts
@src/bridge/router.ts
@src/discord/commands/index.ts
@src/discord/commands/new.ts
@src/discord/commands/stop.ts
@src/discord/commands/status.ts
@src/discord/commands/help.ts
@src/discord/handlers/message.ts
@src/discord/handlers/interaction.ts
@src/discord/components/permission-prompt.ts
@src/discord/components/question-prompt.ts
@src/index.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Discord components and refactor all session commands</name>
  <files>
    src/discord/components/status-embed.ts,
    src/discord/components/session-picker.ts,
    src/discord/commands/new.ts,
    src/discord/commands/stop.ts,
    src/discord/commands/status.ts,
    src/discord/commands/continue.ts,
    src/discord/commands/help.ts,
    src/discord/commands/index.ts
  </files>
  <action>
**1. Create `src/discord/components/status-embed.ts`:**

Export `createStatusEmbed(sessions: ManagedSession[]): EmbedBuilder` function.

```typescript
import { EmbedBuilder } from "discord.js";
import type { ManagedSession } from "../../claude/types.js";
```

Logic:
- If `sessions.length === 0`: Set title "Session Status", description "No active sessions. Use `/new` to start one.", color gray (0x95a5a6).
- If sessions exist: Set title "Session Status", color green (0x57f287).
- For each session, add a field:
  - Name: `Session in <#${session.threadId}>`
  - Value: Lines joined by `\n`:
    - `**Status:** ${session.isProcessing ? "Processing" : "Idle"}`
    - `**Age:** ${formatDuration(Date.now() - session.startedAt.getTime())}`
    - `**Messages:** ${session.messageCount}`
    - `**Tokens:** ${session.totalInputTokens.toLocaleString()} in / ${session.totalOutputTokens.toLocaleString()} out`
    - `**Cost:** $${session.totalCostUsd.toFixed(4)}`
- Footer: `Total cost: $${totalCost.toFixed(4)}` where totalCost sums all sessions.

Also export a helper `formatDuration(ms: number): string` that returns human-readable duration:
- Under 60s: `${s}s`
- Under 3600s: `${m}m ${s}s`
- Otherwise: `${h}h ${m}m`

Also export `createResumeEmbed(session: ManagedSession): EmbedBuilder` for `/continue`:
- Title: "Session Resumed"
- Color: 0x5865f2 (Discord blurple)
- Fields: Started, Messages, Cost (same format as status)
- Description: "Continuing session in this thread."

**2. Create `src/discord/components/session-picker.ts`:**

Export `createSessionPicker(sessions: ManagedSession[]): ActionRowBuilder<StringSelectMenuBuilder>` function.

```typescript
import {
  StringSelectMenuBuilder,
  StringSelectMenuOptionBuilder,
  ActionRowBuilder,
} from "discord.js";
import type { ManagedSession } from "../../claude/types.js";
```

Logic:
- Create StringSelectMenuBuilder with customId `"stop_session_picker"`, placeholder "Select a session to stop".
- For each session, add an option:
  - Label: truncate thread ID reference to fit (use `Session ${index + 1}` or similar short label)
  - Description: `${session.messageCount} msgs, $${session.totalCostUsd.toFixed(4)}, age: ${formatDuration(...)}`
  - Value: `session.threadId`
- Import `formatDuration` from `./status-embed.js`.

**3. Refactor `src/discord/commands/new.ts`:**

Replace the simple callback pattern with direct SessionManager and BridgeRouter integration.

New approach -- use setter functions like the existing pattern but with richer types:

```typescript
export type OnNew = (interaction: ChatInputCommandInteraction) => Promise<void>;
let onNew: OnNew = async (interaction) => {
  await interaction.editReply("Not initialized.");
};
export function setOnNew(fn: OnNew): void { onNew = fn; }
```

The `execute` function just calls `await onNew(interaction)`. The actual logic lives in the setter callback wired from index.ts.

The callback (wired in index.ts) should:
1. Check `sessionManager.hasAnySessions()`.
2. If sessions exist: send warning embed with "Start New Session" / "Cancel" buttons. Wait for button click (60s timeout). If confirm, proceed. If cancel or timeout, reply "Cancelled."
3. Create a thread in the configured channel: `channel.threads.create({ name: "Claude Session - {timestamp}", autoArchiveDuration: ThreadAutoArchiveDuration.OneDay })`. The timestamp format: "Feb 15, 5:30 PM" (use `new Date().toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' })`).
4. Call `sessionManager.createSession(thread.id, thread.url)`.
5. Reply: `New session started in <#${thread.id}>`.
6. Update bot presence (call the presence updater).

Use the interaction's channel to get the TextChannel. The interaction is guaranteed to be in the configured channel by the interaction handler.

**4. Refactor `src/discord/commands/stop.ts`:**

Same pattern -- setter callback with richer type:

```typescript
export type OnStop = (interaction: ChatInputCommandInteraction) => Promise<void>;
let onStop: OnStop = async (interaction) => {
  await interaction.editReply("Not initialized.");
};
export function setOnStop(fn: OnStop): void { onStop = fn; }
```

The callback (wired in index.ts) should:
1. Get `sessionManager.getAllSessions()`.
2. If no sessions: reply "No active sessions to stop."
3. If exactly 1 session: destroy it immediately. Reply with summary of what was completed: "Session stopped. {messageCount} messages, cost: ${cost}". Update presence.
4. If multiple sessions: send the session picker select menu. Wait for selection (60s timeout via `awaitMessageComponent`). On selection, destroy the selected session. Update the reply to confirm. On timeout, edit reply to "Timed out -- no session stopped." and remove the select menu.

**5. Create `src/discord/commands/continue.ts`:**

New command file:

```typescript
import { ChatInputCommandInteraction, SlashCommandBuilder } from "discord.js";

export type OnContinue = (interaction: ChatInputCommandInteraction) => Promise<void>;
let onContinue: OnContinue = async (interaction) => {
  await interaction.editReply("Not initialized.");
};
export function setOnContinue(fn: OnContinue): void { onContinue = fn; }

export const data = new SlashCommandBuilder()
  .setName("continue")
  .setDescription("Resume the most recent Claude session");

export async function execute(interaction: ChatInputCommandInteraction): Promise<void> {
  await onContinue(interaction);
}
```

The callback (wired in index.ts) should:
1. Call `sessionManager.getMostRecentSession()`.
2. If no session: reply "No previous session found. Use `/new` to start one."
3. If session found and `session.claudeSession.isAlive()`: Post a resume embed in the session's thread (using `createResumeEmbed`). Reply in the channel: `Session resumed in <#${session.threadId}>`.
4. If session found but not alive: Reply with warning embed: "Session expired (Claude process died). Start a fresh session or abort?" with two buttons (Start Fresh / Abort). On Start Fresh: destroy the dead session, call the `/new` logic. On Abort: destroy the dead session, reply "Session cleaned up."

**6. Refactor `src/discord/commands/status.ts`:**

Replace the string getter pattern with a richer callback:

```typescript
export type GetStatus = (interaction: ChatInputCommandInteraction) => Promise<void>;
let getStatus: GetStatus = async (interaction) => {
  await interaction.editReply("Not initialized.");
};
export function setStatusHandler(fn: GetStatus): void { getStatus = fn; }
```

The callback (wired in index.ts) should:
1. Get all sessions from SessionManager.
2. Create a status embed using `createStatusEmbed(sessions)`.
3. Reply with the embed: `interaction.editReply({ embeds: [embed] })`.

**7. Update `src/discord/commands/help.ts`:**

Update the help text to reflect the new multi-session commands:
- `/new` -- Start a new Claude session (auto-creates a thread)
- `/stop` -- Stop an active session (pick from list if multiple)
- `/continue` -- Resume the most recent session
- `/status` -- Show all active sessions with costs and token usage
- Remove or update the line about "Each message creates a thread" -- now `/new` creates sessions, or messages in the main channel auto-create one.
- Add: "Each session lives in its own **thread**. Send messages in the thread to continue the conversation."

**8. Update `src/discord/commands/index.ts`:**

Add the `continue` command to the commands array:

```typescript
import * as continueCmd from "./continue.js";
```

Add to the commands array:
```typescript
{ data: continueCmd.data, execute: continueCmd.execute },
```
  </action>
  <verify>
Run `npx tsc --noEmit`. Expect some errors in index.ts (old wiring) until Task 2 updates it. The command files themselves should compile since they use the setter pattern with lazy initialization.
  </verify>
  <done>
All 4 session commands (/new, /stop, /continue, /status) are implemented with setter callbacks. Status embed and session picker components exist. Help text is updated. /continue command is registered. Commands compile (pending index.ts wiring).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SessionManager, update message handler, add bot presence, and integrate</name>
  <files>
    src/index.ts,
    src/discord/handlers/message.ts
  </files>
  <action>
**1. Refactor `src/index.ts`:**

Replace the single ClaudeSession + BridgeRouter setup with SessionManager-based wiring.

Import changes:
```typescript
import { SessionManager } from "./bridge/session-manager.js";
// Remove: import { ClaudeSession } from "./claude/session.js";
// Add:
import { setOnContinue } from "./discord/commands/continue.js";
import { setStatusHandler } from "./discord/commands/status.js";
// Update existing imports as needed
import { PresenceUpdateStatus, ActivityType, Events, type TextChannel, ThreadAutoArchiveDuration } from "discord.js";
```

Create SessionManager instead of ClaudeSession:
```typescript
const sessionManager = new SessionManager({
  cwd,
  ipcPort: config.ipcPort,
  dangerouslySkipPermissions: config.dangerouslySkipPermissions,
});
```

Create BridgeRouter with SessionManager (new constructor signature from Plan 01):
```typescript
const router = new BridgeRouter(sessionManager, ipcServer, permissionHandler);
```

Wire the message handler:
```typescript
setRouter(router);
setSessionManager(sessionManager); // New setter on message handler
```

**Bot Presence Helper:**
Create a `updatePresence()` function in index.ts (not a separate file -- it needs access to `client` and `sessionManager`):

```typescript
function updatePresence(): void {
  const sessions = sessionManager.getAllSessions();
  const active = sessions.length;
  const processing = sessions.some(s => s.isProcessing);

  if (active === 0) {
    client.user?.setPresence({
      status: PresenceUpdateStatus.Online,
      activities: [{ name: "Ready", type: ActivityType.Watching }],
    });
  } else if (processing) {
    client.user?.setPresence({
      status: PresenceUpdateStatus.DoNotDisturb,
      activities: [{ name: "Working...", type: ActivityType.Playing }],
    });
  } else {
    client.user?.setPresence({
      status: PresenceUpdateStatus.Idle,
      activities: [{
        name: `${active} session${active > 1 ? "s" : ""} active`,
        type: ActivityType.Watching,
      }],
    });
  }
}
```

Wire command callbacks that use SessionManager, router, and updatePresence:

**setOnNew callback:**
```typescript
setOnNew(async (interaction) => {
  const channel = interaction.channel as TextChannel;

  // Warn if sessions are active
  if (sessionManager.hasAnySessions()) {
    const { EmbedBuilder, ButtonBuilder, ButtonStyle, ActionRowBuilder } = await import("discord.js");
    const warnEmbed = new EmbedBuilder()
      .setTitle("Active Session Warning")
      .setDescription(`You have ${sessionManager.getActiveSessionCount()} active session(s). Start a new one anyway?`)
      .setColor(0xffa500);

    const buttons = new ActionRowBuilder<ButtonBuilder>().addComponents(
      new ButtonBuilder().setCustomId("new_confirm").setLabel("Start New Session").setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId("new_cancel").setLabel("Cancel").setStyle(ButtonStyle.Secondary),
    );

    const reply = await interaction.editReply({ embeds: [warnEmbed], components: [buttons] });
    try {
      const btnInteraction = await reply.awaitMessageComponent({ time: 60_000 });
      if (btnInteraction.customId === "new_cancel") {
        warnEmbed.setColor(0x95a5a6).setFooter({ text: "Cancelled" });
        await btnInteraction.update({ embeds: [warnEmbed], components: [] });
        return;
      }
      await btnInteraction.update({ embeds: [warnEmbed], components: [] });
    } catch {
      // Timeout
      warnEmbed.setColor(0x95a5a6).setFooter({ text: "Timed out" });
      await interaction.editReply({ embeds: [warnEmbed], components: [] });
      return;
    }
  }

  // Create thread
  const timestamp = new Date().toLocaleString("en-US", { month: "short", day: "numeric", hour: "numeric", minute: "2-digit" });
  const thread = await channel.threads.create({
    name: `Claude Session - ${timestamp}`,
    autoArchiveDuration: ThreadAutoArchiveDuration.OneDay,
    reason: "Claude session",
  });

  sessionManager.createSession(thread.id, thread.url);
  await interaction.editReply(`New session started in <#${thread.id}>`);
  updatePresence();
});
```

**setOnStop callback:**
```typescript
setOnStop(async (interaction) => {
  const sessions = sessionManager.getAllSessions();
  if (sessions.length === 0) {
    await interaction.editReply("No active sessions to stop.");
    return;
  }

  if (sessions.length === 1) {
    const session = sessions[0];
    sessionManager.destroySession(session.threadId);
    await interaction.editReply(`Session stopped. ${session.messageCount} messages, cost: $${session.totalCostUsd.toFixed(4)}`);
    updatePresence();
    return;
  }

  // Multiple sessions -- show picker
  const { createSessionPicker } = await import("./discord/components/session-picker.js");
  const picker = createSessionPicker(sessions);
  const reply = await interaction.editReply({ content: "Select a session to stop:", components: [picker] });

  try {
    const selectInteraction = await reply.awaitMessageComponent({ time: 60_000 });
    if (selectInteraction.isStringSelectMenu()) {
      const threadId = selectInteraction.values[0];
      const session = sessionManager.getSession(threadId);
      if (session) {
        sessionManager.destroySession(threadId);
        await selectInteraction.update({
          content: `Session stopped. ${session.messageCount} messages, cost: $${session.totalCostUsd.toFixed(4)}`,
          components: [],
        });
      } else {
        await selectInteraction.update({ content: "Session not found.", components: [] });
      }
    }
  } catch {
    await interaction.editReply({ content: "Timed out -- no session stopped.", components: [] });
  }
  updatePresence();
});
```

**setOnContinue callback:**
```typescript
setOnContinue(async (interaction) => {
  const session = sessionManager.getMostRecentSession();
  if (!session) {
    await interaction.editReply("No previous session found. Use `/new` to start one.");
    return;
  }

  if (session.claudeSession.isAlive()) {
    // Post resume embed in the session's thread
    const { createResumeEmbed } = await import("./discord/components/status-embed.js");
    const embed = createResumeEmbed(session);
    try {
      const thread = await client.channels.fetch(session.threadId);
      if (thread?.isThread()) {
        // Unarchive if needed
        if (thread.archived) await thread.setArchived(false);
        await thread.send({ embeds: [embed] });
      }
    } catch (err) {
      logger.warn({ err }, "Failed to post resume embed in thread");
    }
    await interaction.editReply(`Session resumed in <#${session.threadId}>`);
  } else {
    // Session died -- ask user what to do
    const { EmbedBuilder, ButtonBuilder, ButtonStyle, ActionRowBuilder } = await import("discord.js");
    const warnEmbed = new EmbedBuilder()
      .setTitle("Session Expired")
      .setDescription("The Claude process for this session has died. Start a fresh session or clean up?")
      .setColor(0xed4245);

    const buttons = new ActionRowBuilder<ButtonBuilder>().addComponents(
      new ButtonBuilder().setCustomId("continue_fresh").setLabel("Start Fresh").setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId("continue_abort").setLabel("Clean Up").setStyle(ButtonStyle.Secondary),
    );

    const reply = await interaction.editReply({ embeds: [warnEmbed], components: [buttons] });
    try {
      const btnInteraction = await reply.awaitMessageComponent({ time: 60_000 });
      sessionManager.destroySession(session.threadId);
      if (btnInteraction.customId === "continue_fresh") {
        // Trigger /new logic -- create a new session
        await btnInteraction.update({ content: "Starting fresh session...", embeds: [], components: [] });
        // Reuse the onNew callback by importing it
        const { onNew } = await import("./discord/commands/new.js");
        await onNew(interaction);
      } else {
        await btnInteraction.update({ content: "Session cleaned up.", embeds: [], components: [] });
      }
    } catch {
      sessionManager.destroySession(session.threadId);
      await interaction.editReply({ content: "Timed out -- session cleaned up.", embeds: [], components: [] });
    }
    updatePresence();
  }
});
```

**setStatusHandler callback:**
```typescript
setStatusHandler(async (interaction) => {
  const { createStatusEmbed } = await import("./discord/components/status-embed.js");
  const sessions = sessionManager.getAllSessions();
  const embed = createStatusEmbed(sessions);
  await interaction.editReply({ embeds: [embed] });
});
```

**Graceful shutdown:**
Update the `shutdown` function:
- Replace `session.destroy()` with `sessionManager.destroyAllSessions()`.
- Keep the IPC server stop.
- Keep the Discord client destroy.
- Update the `process.on("exit")` handler similarly.

**2. Refactor `src/discord/handlers/message.ts`:**

Add SessionManager awareness for thread-based routing.

Add a setter for SessionManager:
```typescript
import type { SessionManager } from "../../bridge/session-manager.js";

let sessionManager: SessionManager | null = null;
export function setSessionManager(sm: SessionManager): void {
  sessionManager = sm;
}
```

Update `handleMessage`:
- Keep all existing guards (bot, channel, owner).
- After guards pass, check if the message is in a thread:
  ```typescript
  if (message.channel.isThread()) {
    // Check if this thread belongs to a session
    const session = sessionManager?.getSession(message.channel.id);
    if (session && router) {
      await router.handleSessionMessage(message, message.channel as ThreadChannel, session);
    }
    // else: not a session thread, ignore
    return;
  }
  ```
- For main channel messages (not in thread): call `router.handleNewMessage(message)` instead of `router.handleMessage(message)`.
- Import `ThreadChannel` from discord.js.

Note: The channel guard `message.channel.id !== config.channelId` needs adjustment for thread messages. Threads have their own ID, not the parent channel ID. Check `message.channel.isThread()` FIRST. For threads, check `message.channel.parentId === config.channelId`. For non-threads, check `message.channel.id === config.channelId`. Update the guard logic accordingly.

**3. Presence on ClientReady:**
In the `Events.ClientReady` handler, call `updatePresence()` to set initial state to Online/Ready.
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- full project should compile with zero errors.
2. Verify all slash commands are registered (5 total: help, status, stop, new, continue).
3. Check that `src/index.ts` no longer imports `ClaudeSession` directly -- only `SessionManager`.
4. Check that message handler routes thread messages to `handleSessionMessage` and main channel messages to `handleNewMessage`.
  </verify>
  <done>
SessionManager wired as central registry. All 4 session commands have full callback implementations. Message handler routes by thread vs main channel. Bot presence updates on session lifecycle changes. Graceful shutdown destroys all sessions. Project compiles.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end multi-session system</name>
  <what-built>
Complete multi-session system with /new, /stop, /continue, /status commands, bot presence, thread-based routing, cost tracking, and session picker.
  </what-built>
  <action>Human verification of the complete multi-session system.</action>
  <how-to-verify>
1. Start the bot: `npx tsx src/index.ts`
2. Verify bot shows "Ready" with green status in Discord.
3. **Test /new:**
   - Run `/new` -- should create a thread named "Claude Session - {timestamp}" and reply with a thread link.
   - Run `/new` again -- should show warning embed with "Start New Session" / "Cancel" buttons.
   - Click "Start New Session" -- should create a second thread.
   - Check bot presence -- should show yellow (Idle) with "2 sessions active".
4. **Test thread messaging:**
   - Send a message in one of the session threads.
   - Verify Claude receives and responds in that thread.
   - Check bot presence turns red (DoNotDisturb) while processing, then back to yellow.
5. **Test /status:**
   - Run `/status` -- should show rich embed with both sessions listed.
   - Verify token counts and cost are displayed.
6. **Test /stop:**
   - Run `/stop` -- should show session picker (select menu) since 2 sessions are active.
   - Select one session -- should stop it and confirm.
   - Run `/stop` again with 1 remaining session -- should stop directly (no picker).
   - Check bot presence -- should be green (Online) with "Ready".
7. **Test /continue:**
   - Run `/new` to create a session, send a message, then run `/continue`.
   - Should post resume embed in the session thread.
8. **Test main channel messages (backward compat):**
   - Send a message in the main channel (not in a thread).
   - Should auto-create a session with a thread, same as before.
9. **Test /help:**
   - Run `/help` -- should show updated command descriptions.
  </how-to-verify>
  <verify>Follow the how-to-verify steps above.</verify>
  <done>All session lifecycle commands work end-to-end, bot presence reflects session state, multi-session routing is correct.</done>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero errors
2. All 5 slash commands registered (help, status, stop, new, continue)
3. Bot presence changes with session state (green/yellow/red)
4. Multiple concurrent sessions work independently
5. /status shows rich embed with per-session and total cost info
6. /stop shows picker for multiple sessions, direct stop for single session
7. /continue resumes most recent session, handles dead sessions gracefully
8. /new warns about active sessions with confirm/cancel buttons
9. Main channel messages still work (backward compatible)
10. Thread messages route to the correct session
</verification>

<success_criteria>
- User can create, stop, resume, and inspect sessions via slash commands
- Multiple concurrent sessions work independently in different threads
- Bot presence reflects session state (ready/active/working)
- Cost and token tracking displayed in /status embed
- Dead sessions handled gracefully in /continue
- Session picker shown for /stop with multiple sessions
- Backward compatible: main channel messages still create sessions
</success_criteria>

<output>
After completion, create `.planning/phases/03-session-persistence/03-02-SUMMARY.md`
</output>
