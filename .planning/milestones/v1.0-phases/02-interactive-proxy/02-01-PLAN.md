---
phase: 02-interactive-proxy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/mcp/permission-server.ts
  - src/mcp/ipc-client.ts
  - src/bridge/ipc-server.ts
autonomous: true

must_haves:
  truths:
    - "MCP permission server can receive tool permission requests from Claude CLI via stdio JSON-RPC"
    - "MCP permission server forwards requests to bot process via HTTP and blocks until response"
    - "IPC server in bot process receives HTTP POST requests and emits events for downstream handling"
  artifacts:
    - path: "src/mcp/permission-server.ts"
      provides: "MCP server entry point with permission_prompt tool"
      contains: "McpServer"
    - path: "src/mcp/ipc-client.ts"
      provides: "HTTP client for MCP server to call bot IPC endpoint"
      exports: ["forwardPermissionRequest"]
    - path: "src/bridge/ipc-server.ts"
      provides: "HTTP server receiving MCP permission requests in bot process"
      exports: ["IpcServer"]
  key_links:
    - from: "src/mcp/permission-server.ts"
      to: "src/mcp/ipc-client.ts"
      via: "import forwardPermissionRequest"
      pattern: "forwardPermissionRequest"
    - from: "src/mcp/ipc-client.ts"
      to: "src/bridge/ipc-server.ts"
      via: "HTTP POST to localhost:IPC_PORT/permission"
      pattern: "fetch.*permission"
---

<objective>
Create the MCP permission server (Claude-side subprocess) and IPC bridge infrastructure (bot-side HTTP server) that enable tool permission requests to flow from Claude CLI to the Discord bot process.

Purpose: This is the load-bearing architecture of Phase 2. Claude CLI's --permission-prompt-tool flag routes all tool approval decisions through a custom MCP server. That MCP server must communicate with the Discord bot (a separate process) via HTTP IPC. Without this bridge, permissions cannot be forwarded to Discord.

Output: Three new files (permission-server.ts, ipc-client.ts, ipc-server.ts) plus new npm dependencies (@modelcontextprotocol/sdk, zod).
</objective>

<execution_context>
@/Users/erictrang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/erictrang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interactive-proxy/02-RESEARCH.md
@src/claude/process.ts
@src/claude/types.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MCP deps and create MCP permission server with IPC client</name>
  <files>package.json, src/mcp/permission-server.ts, src/mcp/ipc-client.ts</files>
  <action>
Install @modelcontextprotocol/sdk and zod as production dependencies:
```bash
npm install @modelcontextprotocol/sdk zod
```

Create src/mcp/ipc-client.ts:
- Export an async function `forwardPermissionRequest(port: number, request: PermissionRequest): Promise<PermissionDecision>`
- PermissionRequest type: `{ tool_use_id: string; tool_name: string; input: unknown }`
- PermissionDecision type: `{ behavior: "allow" | "deny"; updatedInput?: unknown; message?: string }`
- Uses native `fetch()` to POST JSON to `http://127.0.0.1:${port}/permission`
- Set a 6-minute timeout on the fetch (longer than the 5-min Discord button timeout) using AbortController
- On fetch error or timeout, return `{ behavior: "deny", message: "IPC communication failed" }`
- Export the PermissionRequest and PermissionDecision types for shared use

Create src/mcp/permission-server.ts:
- This is a STANDALONE entry point (separate process spawned by Claude CLI)
- Import McpServer from `@modelcontextprotocol/sdk/server/mcp.js`
- Import StdioServerTransport from `@modelcontextprotocol/sdk/server/stdio.js`
- Import z from zod
- Read IPC port from `process.env.GSD_IPC_PORT` (default "9824")
- Create McpServer instance with name "gsdproxy-permissions", version "1.0.0"
- Register a tool called "permission_prompt" with Zod schema: `{ tool_use_id: z.string(), tool_name: z.string(), input: z.any() }`
- Tool handler: call forwardPermissionRequest with the port and request, return the result as JSON text content
- Connect via StdioServerTransport
- CRITICAL: Never use console.log (stdout is MCP transport). Use console.error for all logging.
- Handle SIGTERM gracefully: close the server and exit
  </action>
  <verify>
1. `npm ls @modelcontextprotocol/sdk zod` shows both installed
2. `npx tsc --noEmit` passes with no errors
3. src/mcp/permission-server.ts exists and contains McpServer, StdioServerTransport, and "permission_prompt" tool
4. src/mcp/ipc-client.ts exists and exports forwardPermissionRequest
  </verify>
  <done>MCP permission server entry point compiles and has a permission_prompt tool that forwards requests to the bot via HTTP IPC client. No console.log usage in permission-server.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create IPC server for bot process</name>
  <files>src/bridge/ipc-server.ts</files>
  <action>
Create src/bridge/ipc-server.ts:
- Import createServer, IncomingMessage, ServerResponse from `node:http`
- Import EventEmitter from `node:events`
- Import the PermissionRequest and PermissionDecision types from `../mcp/ipc-client.js`

Export class IpcServer extending EventEmitter:
- Constructor takes port number
- `start(): Promise<void>` -- starts HTTP server listening on 127.0.0.1:port. Returns a promise that resolves when the server is listening.
- `stop(): Promise<void>` -- closes the HTTP server. Rejects any pending permission requests with deny.
- Private `handleRequest(req, res)` method:
  - Only handle POST /permission
  - Read request body, parse as JSON into PermissionRequest
  - Emit a "permission-request" event with the request object and a resolve callback
  - The resolve callback, when called with a PermissionDecision, writes the JSON response and ends the HTTP response
  - If the event has no listeners, immediately respond with `{ behavior: "deny", message: "No permission handler registered" }`
  - Any other path: respond 404
- Track pending requests in a Map<string, ServerResponse> keyed by tool_use_id, so they can be cleaned up on stop()
- Helper function `readBody(req: IncomingMessage): Promise<string>` to read the full request body

Type the EventEmitter events properly using declaration merging or interface:
```typescript
interface IpcServerEvents {
  "permission-request": (request: PermissionRequest, resolve: (decision: PermissionDecision) => void) => void;
}
```
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no errors
2. src/bridge/ipc-server.ts exports IpcServer class
3. IpcServer has start(), stop() methods and emits "permission-request" events
  </verify>
  <done>IPC server can receive HTTP POST /permission requests from the MCP server, emit events for permission handling, and return decisions as HTTP responses. Pending requests are tracked and cleaned up on stop().</done>
</task>

</tasks>

<verification>
1. `npm ls @modelcontextprotocol/sdk zod` confirms dependencies installed
2. `npx tsc --noEmit` passes -- all new files compile without errors
3. All three new files exist: src/mcp/permission-server.ts, src/mcp/ipc-client.ts, src/bridge/ipc-server.ts
4. permission-server.ts uses console.error (never console.log)
5. IPC communication flow is structurally complete: MCP server -> HTTP POST -> IPC server -> event emission
</verification>

<success_criteria>
- MCP permission server can be launched as a standalone process and connects via StdioServerTransport
- IPC client makes HTTP POST requests with timeout handling
- IPC server receives requests and emits events for downstream handling
- All TypeScript compiles without errors
- No console.log in MCP server code (stdout reserved for MCP protocol)
</success_criteria>

<output>
After completion, create `.planning/phases/02-interactive-proxy/02-01-SUMMARY.md`
</output>
