---
phase: 02-interactive-proxy
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/bridge/streaming-message.ts
  - src/bridge/router.ts
  - src/index.ts
  - src/discord/formatter.ts
autonomous: false

must_haves:
  truths:
    - "Each Claude session creates a Discord thread where detailed output and tool activity are posted"
    - "Main channel receives a concise summary with a link to the thread"
    - "Long responses (>1500 chars) post summary in-channel and full output in thread"
    - "User can see Claude's response streaming in real-time via debounced message edits in the thread"
    - "Tool activity indicators show what Claude is currently doing"
    - "Permission requests from MCP IPC server trigger Discord button prompts"
    - "Permission decisions flow back through IPC to MCP server to Claude"
  artifacts:
    - path: "src/bridge/streaming-message.ts"
      provides: "StreamingMessage class for debounced message edits"
      exports: ["StreamingMessage"]
    - path: "src/bridge/router.ts"
      provides: "Rewritten BridgeRouter with thread, streaming, and IPC integration"
      exports: ["BridgeRouter"]
    - path: "src/index.ts"
      provides: "Updated wiring with IPC server and permission handler"
      contains: "IpcServer"
  key_links:
    - from: "src/bridge/router.ts"
      to: "src/bridge/streaming-message.ts"
      via: "import StreamingMessage for real-time output"
      pattern: "StreamingMessage"
    - from: "src/bridge/router.ts"
      to: "src/bridge/ipc-server.ts"
      via: "IPC server passed to router for permission event handling"
      pattern: "ipcServer"
    - from: "src/bridge/router.ts"
      to: "src/bridge/permission-handler.ts"
      via: "Permission handler called on IPC permission events"
      pattern: "permissionHandler"
    - from: "src/index.ts"
      to: "src/bridge/ipc-server.ts"
      via: "Creates and starts IPC server"
      pattern: "ipcServer.start"
    - from: "src/index.ts"
      to: "src/bridge/permission-handler.ts"
      via: "Creates PermissionHandler and wires to IPC events"
      pattern: "PermissionHandler"
---

<objective>
Integrate threads, real-time streaming, and permission handling into the bridge router. Create the StreamingMessage utility, rewrite the router to use threads for detailed output and summaries in the main channel, and wire the IPC server + permission handler into the application lifecycle.

Purpose: This is the final integration plan that brings all Phase 2 components together. After this plan, the user experiences the full interactive proxy: permission buttons in Discord, streaming output in threads, and concise summaries in the main channel.

Output: New StreamingMessage class, rewritten BridgeRouter, and updated index.ts wiring.
</objective>

<execution_context>
@/Users/erictrang/.claude/get-shit-done/workflows/execute-plan.md
@/Users/erictrang/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interactive-proxy/02-RESEARCH.md
@.planning/phases/02-interactive-proxy/02-01-SUMMARY.md
@.planning/phases/02-interactive-proxy/02-02-SUMMARY.md
@.planning/phases/02-interactive-proxy/02-03-SUMMARY.md
@src/bridge/router.ts
@src/index.ts
@src/discord/formatter.ts
@src/claude/process.ts
@src/claude/types.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StreamingMessage utility class</name>
  <files>src/bridge/streaming-message.ts</files>
  <action>
Create src/bridge/streaming-message.ts:

Export class StreamingMessage:
- Constructor takes a Discord Message object (the message to edit in-place)
- Private properties:
  - `message: Message` -- the Discord message being edited
  - `accumulatedText: string = ""` -- full accumulated response text
  - `editTimer: NodeJS.Timeout | null = null` -- debounce timer
  - `DEBOUNCE_MS = 1500` -- 1.5 second debounce (safe for Discord rate limits)
  - `MAX_DISPLAY_LENGTH = 1800` -- leave 100-char buffer below Discord's 2000 limit
  - `isFinished = false` -- prevents edits after flush

- Method `appendText(text: string): void`
  - Append text to accumulatedText
  - Call scheduleEdit() to debounce the message edit

- Method `getAccumulatedText(): string`
  - Returns the full accumulated text (for use after completion)

- Private method `scheduleEdit(): void`
  - If already scheduled or finished, return
  - Set editTimer to setTimeout at DEBOUNCE_MS that calls doEdit()

- Private async method `doEdit(): Promise<void>`
  - Clear editTimer
  - Truncate display text to MAX_DISPLAY_LENGTH
  - If text exceeds MAX_DISPLAY_LENGTH, append "\n\n*... streaming (full output in thread)*"
  - Edit the message with the display text
  - Catch and log any edit errors (message may be deleted)

- Method `async flush(): Promise<void>`
  - Set isFinished = true
  - Clear any pending editTimer
  - Do one final edit with the accumulated text (truncated to MAX_DISPLAY_LENGTH if needed)
  - If text exceeds MAX_DISPLAY_LENGTH, final display shows truncated text + thread notice

- Method `setStatus(status: string): void`
  - Directly edit the message with the status text (not debounced -- status updates are infrequent)
  - Only if not finished
  - Catch and ignore errors
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. src/bridge/streaming-message.ts exports StreamingMessage class
3. StreamingMessage has appendText, flush, setStatus, getAccumulatedText methods
4. DEBOUNCE_MS is 1500 (1.5 seconds)
5. MAX_DISPLAY_LENGTH is 1800 (100-char buffer)
  </verify>
  <done>StreamingMessage class provides debounced message editing for real-time streaming display, with truncation at 1800 chars and a final flush method.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite router with threads, streaming, IPC, and update index.ts wiring</name>
  <files>src/bridge/router.ts, src/index.ts, src/discord/formatter.ts</files>
  <action>
This is the core integration task. The BridgeRouter needs significant rework to support threads, streaming, and permission handling.

**Modify src/discord/formatter.ts:**
- Add a new export function `formatSummary(fullText: string, threadLink: string): string`
  - If fullText length <= 1500, return fullText + `\n\n*Details: ${threadLink}*`
  - If fullText length > 1500, truncate to 1500 chars at a natural break (paragraph > line > space), append `...\n\n*Full output: ${threadLink}*`
  - This produces the main-channel summary message

**Rewrite src/bridge/router.ts:**

Update imports:
- Add imports for: IpcServer, PermissionHandler, StreamingMessage
- Add imports for: ThreadAutoArchiveDuration, ThreadChannel from discord.js
- Keep existing imports for process spawning, parsing, formatting

Update BridgeRouter constructor:
- Accept additional parameters: `ipcServer: IpcServer`, `permissionHandler: PermissionHandler`
- Store them as private properties
- Wire the IPC server's "permission-request" event to a handler method

Add private property `private activeThread: ThreadChannel | null = null`

**Rewrite handleMessage method:**

The new flow for each message:

1. Queue check (same as before -- if processing, queue with notification)
2. Set isProcessing = true
3. Create a Discord thread for this session:
   ```typescript
   const threadName = message.content.slice(0, 95) + (message.content.length > 95 ? "..." : "");
   const thread = await channel.threads.create({
     name: threadName,
     autoArchiveDuration: ThreadAutoArchiveDuration.OneHour,
     reason: "Claude session output",
   });
   this.activeThread = thread;
   ```
4. Post initial status in thread: `const statusMsg = await thread.send("*Working on it...*")`
5. Create StreamingMessage wrapping statusMsg
6. Start typing indicator on the MAIN channel (keep user aware something is happening)
7. Spawn Claude process (now passing ipcPort via options)
8. Parse stream events, routing text to StreamingMessage.appendText(), tool activity to StreamingMessage.setStatus()
9. When stream completes:
   a. Flush StreamingMessage
   b. Stop typing indicator
   c. Post full accumulated text to thread via splitMessage (the thread gets the complete output)
   d. Post result info to thread (turns, cost)
   e. Post summary to main channel via formatSummary with thread link
   f. Clear activeThread

**IPC permission request handling:**
- When a "permission-request" event fires from the IPC server:
  - Determine the target channel for prompts: use activeThread if available, fall back to the main channel
  - Call permissionHandler.handlePermissionRequest(request, targetChannel)
  - Pass the returned PermissionDecision back to the IPC server's resolve callback
  - While waiting for user response, update the streaming message status to "*Waiting for permission approval...*"

**Update the handleStreamEvent method:**
- Replace ctx.statusMessage with StreamingMessage
- Text deltas go to streamingMessage.appendText(text) instead of simple accumulation
- Tool activity goes to streamingMessage.setStatus(activity) instead of statusMessage.edit()
- The status message pattern (edit-in-place) is replaced by StreamingMessage

**Keep unchanged:**
- abort() method (add: clear activeThread)
- getStatus() method (add: threadId info)
- resetSession() method
- startTypingLoop() method
- processQueue() method

**Modify src/index.ts:**

- Add imports: IpcServer from bridge/ipc-server.js, PermissionHandler from bridge/permission-handler.js
- Create IpcServer instance with config.ipcPort
- Create PermissionHandler instance
- Pass ipcServer and permissionHandler to BridgeRouter constructor
- Start the IPC server before Discord login:
  ```typescript
  await ipcServer.start();
  logger.info({ port: config.ipcPort }, "IPC server started");
  ```
- In shutdown function: stop the IPC server (`ipcServer.stop()`) before destroying Discord client
- Update spawnClaude call site (if router passes ipcPort through, which it should via the options)
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. BridgeRouter creates threads per session
4. StreamingMessage is used for real-time display
5. IPC permission events trigger PermissionHandler
6. Main channel gets summary, thread gets full output
7. index.ts creates and starts IpcServer
8. Graceful shutdown stops IPC server
  </verify>
  <done>Full integration: threads created per session, streaming via debounced edits in thread, permission prompts displayed in thread, summary posted in main channel with thread link. IPC server starts on bot launch and stops on shutdown.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end verification of interactive proxy</name>
  <files>N/A (verification only)</files>
  <action>
Human verification checkpoint. Verify the complete Phase 2 interactive proxy:
- MCP permission forwarding via Discord buttons
- AskUserQuestion via select menus
- Real-time streaming in threads
- Summary in main channel

Steps:
1. Start the bot with `npm run dev`
2. Send a message in the Discord channel that will trigger a tool use requiring permission (e.g., "Write a hello.txt file in the current directory")
3. Verify: A thread is created in the channel with the message content as thread name
4. Verify: The thread shows streaming output (text appearing progressively)
5. Verify: When Claude requests Write permission, an embed appears with Allow/Deny buttons
6. Click "Allow" -- verify Claude continues execution
7. Verify: After completion, the main channel has a summary message with a link to the thread
8. Verify: The thread has the full detailed output including tool activity
9. Test deny: Send another message requiring permission, click "Deny" -- verify Claude handles denial
10. Test timeout: Send another message requiring permission, wait 5+ minutes -- verify auto-deny with notification
  </action>
  <verify>All 10 verification steps above pass</verify>
  <done>Interactive proxy works end-to-end: permissions via buttons, questions via select menus, streaming in threads, summaries in channel</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Bot starts and IPC server binds to configured port
4. Messages create threads with streaming output
5. Permission requests produce Discord buttons that work
6. AskUserQuestion produces Discord select menus
7. Auto-deny fires after 5 minutes
8. Main channel gets summaries, threads get full output
9. Graceful shutdown cleans up IPC server and pending permissions
</verification>

<success_criteria>
- Thread is created for every message sent to Claude
- Streaming output appears in real-time in the thread via debounced edits
- Permission requests render as embeds with Allow/Deny buttons
- AskUserQuestion renders as select menus with options
- Timeout auto-denies after 5 minutes
- Main channel shows concise summary with thread link
- Long outputs are truncated in main channel, full in thread
- Tool activity indicators show what Claude is doing
- All Phase 2 success criteria from ROADMAP.md are met
</success_criteria>

<output>
After completion, create `.planning/phases/02-interactive-proxy/02-04-SUMMARY.md`
</output>
